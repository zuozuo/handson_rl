<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>悬崖漫步环境可视化</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        border: "hsl(214.3 31.8% 91.4%)",
                        input: "hsl(214.3 31.8% 91.4%)",
                        ring: "hsl(222.2 84% 4.9%)",
                        background: "hsl(0 0% 100%)",
                        foreground: "hsl(222.2 84% 4.9%)",
                        primary: {
                            DEFAULT: "hsl(222.2 47.4% 11.2%)",
                            foreground: "hsl(210 40% 98%)",
                        },
                        secondary: {
                            DEFAULT: "hsl(210 40% 96%)",
                            foreground: "hsl(222.2 84% 4.9%)",
                        },
                        destructive: {
                            DEFAULT: "hsl(0 84.2% 60.2%)",
                            foreground: "hsl(210 40% 98%)",
                        },
                        muted: {
                            DEFAULT: "hsl(210 40% 96%)",
                            foreground: "hsl(215.4 16.3% 46.9%)",
                        },
                        accent: {
                            DEFAULT: "hsl(210 40% 96%)",
                            foreground: "hsl(222.2 84% 4.9%)",
                        },
                        card: {
                            DEFAULT: "hsl(0 0% 100%)",
                            foreground: "hsl(222.2 84% 4.9%)",
                        },
                    },
                    borderRadius: {
                        lg: "var(--radius)",
                        md: "calc(var(--radius) - 2px)",
                        sm: "calc(var(--radius) - 4px)",
                    },
                    animation: {
                        'fade-in': 'fadeIn 0.5s ease-in-out',
                        'slide-up': 'slideUp 0.3s ease-out',
                        'pulse-slow': 'pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                    },
                    keyframes: {
                        fadeIn: {
                            '0%': { opacity: '0', transform: 'translateY(10px)' },
                            '100%': { opacity: '1', transform: 'translateY(0)' },
                        },
                        slideUp: {
                            '0%': { opacity: '0', transform: 'translateY(20px)' },
                            '100%': { opacity: '1', transform: 'translateY(0)' },
                        }
                    }
                }
            }
        }
    </script>
    <style>
        :root {
            --radius: 0.5rem;
        }
        .grid-container {
            display: grid;
            grid-template-columns: repeat(12, 40px);
            grid-template-rows: repeat(4, 40px);
            gap: 1px;
            border-radius: 8px;
            overflow: hidden;
            border: 2px solid hsl(214.3 31.8% 91.4%);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
        }
        .grid-container:hover {
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
        }
        .cell {
            width: 40px;
            height: 40px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 11px;
            background-color: white;
            border-right: 1px solid hsl(214.3 31.8% 91.4%);
            border-bottom: 1px solid hsl(214.3 31.8% 91.4%);
            transition: all 0.2s ease;
            position: relative;
        }
        .cell:nth-child(12n) {
            border-right: none;
        }
        .cell:nth-last-child(-n+12) {
            border-bottom: none;
        }
        .cell:hover {
            background-color: hsl(210 40% 98%);
            transform: scale(1.05);
            z-index: 10;
        }
        .start {
            background: linear-gradient(135deg, hsl(142.1 76.2% 36.3%), hsl(142.1 76.2% 45%));
            color: white;
            box-shadow: inset 0 1px 2px rgba(255, 255, 255, 0.3);
        }
        .goal {
            background: linear-gradient(135deg, hsl(47.9 95.8% 53.1%), hsl(47.9 95.8% 63.1%));
            color: hsl(222.2 84% 4.9%);
            box-shadow: inset 0 1px 2px rgba(255, 255, 255, 0.3);
        }
        .cliff {
            background: linear-gradient(135deg, hsl(0 84.2% 60.2%), hsl(0 84.2% 70.2%));
            color: white;
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.2);
        }
        .value-text {
            font-weight: 400;
            font-size: 9px;
            color: hsl(215.4 16.3% 46.9%);
            margin-top: 2px;
            text-shadow: 0 1px 2px rgba(255, 255, 255, 0.8);
        }
        .start .value-text, .cliff .value-text {
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }
        .algorithm-card {
            background: linear-gradient(135deg, hsl(0 0% 100%), hsl(210 40% 98%));
            border: 1px solid hsl(214.3 31.8% 91.4%);
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            transition: all 0.3s ease;
        }
        .algorithm-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
        }
        .iteration-badge {
            background: linear-gradient(135deg, hsl(217 91% 60%), hsl(217 91% 70%));
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: 600;
            display: inline-block;
            margin-left: 8px;
            animation: pulse-slow;
        }
        .converged-badge {
            background: linear-gradient(135deg, hsl(142.1 76.2% 36.3%), hsl(142.1 76.2% 46.3%));
            animation: none;
        }
    </style>
</head>
<body class="min-h-screen bg-gradient-to-br from-slate-50 to-blue-50">
    <div class="container mx-auto px-6 py-8 max-w-7xl">
        <!-- Header -->
        <div class="text-center mb-12 animate-fade-in">
            <div class="inline-block p-4 bg-gradient-to-r from-blue-600 to-purple-600 rounded-2xl mb-6 shadow-lg">
                <h1 class="text-4xl font-bold text-white mb-2">
                    悬崖漫步环境可视化
                </h1>
                <p class="text-blue-100 text-lg">
                    基于动态规划的强化学习算法演示平台
                </p>
            </div>
            <div class="max-w-3xl mx-auto">
                <p class="text-lg text-muted-foreground leading-relaxed">
                    探索策略迭代与价值迭代算法在悬崖漫步环境中的学习过程，体验不同算法的收敛特性和策略差异
                </p>
            </div>
        </div>
        
        <!-- Legend -->
        <div class="flex justify-center items-center gap-8 mb-12 p-6 bg-card rounded-xl border shadow-sm animate-slide-up">
            <h3 class="text-lg font-semibold text-gray-700">环境说明</h3>
            <div class="flex items-center gap-3">
                <div class="w-6 h-6 rounded-lg bg-gradient-to-br from-green-500 to-green-600 shadow-sm"></div>
                <span class="text-sm font-medium">起点 (S)</span>
            </div>
            <div class="flex items-center gap-3">
                <div class="w-6 h-6 rounded-lg bg-gradient-to-br from-yellow-400 to-yellow-500 shadow-sm"></div>
                <span class="text-sm font-medium">终点 (G)</span>
            </div>
            <div class="flex items-center gap-3">
                <div class="w-6 h-6 rounded-lg bg-gradient-to-br from-red-500 to-red-600 shadow-sm"></div>
                <span class="text-sm font-medium">悬崖 (C)</span>
            </div>
        </div>
        
        <!-- Algorithms -->
        <div class="grid grid-cols-1 xl:grid-cols-2 gap-8">
            <!-- Policy Iteration -->
            <div class="algorithm-card p-8 animate-slide-up" style="animation-delay: 0.1s">
                <div class="border-b border-gray-200 pb-6 mb-8">
                    <div class="flex items-center justify-between">
                        <h2 class="text-2xl font-bold text-blue-700 flex items-center">
                            <div class="w-3 h-3 bg-blue-600 rounded-full mr-3"></div>
                            策略迭代算法
                        </h2>
                        <div class="text-right">
                            <div class="text-xs text-muted-foreground">Policy Iteration</div>
                            <div class="text-sm font-medium text-blue-600">贝尔曼期望方程</div>
                        </div>
                    </div>
                    <div id="policyIterationResults" class="mt-4 text-sm text-muted-foreground min-h-[24px]"></div>
                </div>
                
                <div class="space-y-8">
                    <div class="text-center">
                        <h3 class="text-lg font-semibold mb-6 text-gray-700 flex items-center justify-center">
                            <svg class="w-5 h-5 mr-2 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path>
                            </svg>
                            最优策略
                        </h3>
                        <div class="flex justify-center">
                            <div class="grid-container" id="policyIterationPolicyGrid"></div>
                        </div>
                    </div>
                    
                    <div class="text-center">
                        <h3 class="text-lg font-semibold mb-6 text-gray-700 flex items-center justify-center">
                            <svg class="w-5 h-5 mr-2 text-purple-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 12l3-3 3 3 4-4M8 21l4-4 4 4M3 4h18M4 4h16v12a1 1 0 01-1 1H5a1 1 0 01-1-1V4z"></path>
                            </svg>
                            状态价值
                        </h3>
                        <div class="flex justify-center">
                            <div class="grid-container" id="policyIterationValueGrid"></div>
                        </div>
                    </div>
                </div>
                
                <div class="flex flex-wrap gap-3 mt-8 pt-6 border-t border-gray-200">
                    <button id="policyIterationBtn" class="inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 bg-primary text-primary-foreground hover:bg-primary/90 h-10 px-4 py-2 shadow-md hover:shadow-lg">
                        <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.828 14.828a4 4 0 01-5.656 0M9 10h1m4 0h1m-6 4h.01M19 10a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                        </svg>
                        运行策略迭代
                    </button>
                    <button id="singleStepPolicyBtn" class="inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 border border-input bg-background hover:bg-accent hover:text-accent-foreground h-10 px-4 py-2 shadow-sm hover:shadow-md">
                        <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 9l3 3-3 3m-4-6l3 3-3 3m-6-3h12"></path>
                        </svg>
                        单步执行
                    </button>
                    <button id="resetPolicyIterationBtn" class="inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 bg-destructive text-destructive-foreground hover:bg-destructive/90 h-10 px-4 py-2 shadow-sm hover:shadow-md">
                        <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                        </svg>
                        重置
                    </button>
                </div>
            </div>

            <!-- Value Iteration -->
            <div class="algorithm-card p-8 animate-slide-up" style="animation-delay: 0.2s">
                <div class="border-b border-gray-200 pb-6 mb-8">
                    <div class="flex items-center justify-between">
                        <h2 class="text-2xl font-bold text-green-700 flex items-center">
                            <div class="w-3 h-3 bg-green-600 rounded-full mr-3"></div>
                            价值迭代算法
                        </h2>
                        <div class="text-right">
                            <div class="text-xs text-muted-foreground">Value Iteration</div>
                            <div class="text-sm font-medium text-green-600">贝尔曼最优方程</div>
                        </div>
                    </div>
                    <div id="valueIterationResults" class="mt-4 text-sm text-muted-foreground min-h-[24px]"></div>
                </div>
                
                <div class="space-y-8">
                    <div class="text-center">
                        <h3 class="text-lg font-semibold mb-6 text-gray-700 flex items-center justify-center">
                            <svg class="w-5 h-5 mr-2 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path>
                            </svg>
                            最优策略
                        </h3>
                        <div class="flex justify-center">
                            <div class="grid-container" id="valueIterationPolicyGrid"></div>
                        </div>
                    </div>
                    
                    <div class="text-center">
                        <h3 class="text-lg font-semibold mb-6 text-gray-700 flex items-center justify-center">
                            <svg class="w-5 h-5 mr-2 text-purple-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 12l3-3 3 3 4-4M8 21l4-4 4 4M3 4h18M4 4h16v12a1 1 0 01-1 1H5a1 1 0 01-1-1V4z"></path>
                            </svg>
                            状态价值
                        </h3>
                        <div class="flex justify-center">
                            <div class="grid-container" id="valueIterationValueGrid"></div>
                        </div>
                    </div>
                </div>
                
                <div class="flex flex-wrap gap-3 mt-8 pt-6 border-t border-gray-200">
                    <button id="valueIterationBtn" class="inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 bg-primary text-primary-foreground hover:bg-primary/90 h-10 px-4 py-2 shadow-md hover:shadow-lg">
                        <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path>
                        </svg>
                        运行价值迭代
                    </button>
                    <button id="singleStepValueBtn" class="inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 border border-input bg-background hover:bg-accent hover:text-accent-foreground h-10 px-4 py-2 shadow-sm hover:shadow-md">
                        <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 9l3 3-3 3m-4-6l3 3-3 3m-6-3h12"></path>
                        </svg>
                        单步执行
                    </button>
                    <button id="resetValueIterationBtn" class="inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 bg-destructive text-destructive-foreground hover:bg-destructive/90 h-10 px-4 py-2 shadow-sm hover:shadow-md">
                        <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                        </svg>
                        重置
                    </button>
                </div>
            </div>
        </div>

        <!-- Footer Info -->
        <div class="mt-12 text-center">
            <div class="bg-gradient-to-r from-blue-50 to-purple-50 rounded-xl p-6 border border-blue-100">
                <h3 class="text-lg font-semibold text-gray-700 mb-3">算法对比说明</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm text-muted-foreground">
                    <div class="flex items-start">
                        <div class="w-2 h-2 bg-blue-600 rounded-full mt-2 mr-3 flex-shrink-0"></div>
                        <div>
                            <span class="font-medium text-blue-700">策略迭代：</span>
                            先进行策略评估，再进行策略提升，直到策略收敛
                        </div>
                    </div>
                    <div class="flex items-start">
                        <div class="w-2 h-2 bg-green-600 rounded-full mt-2 mr-3 flex-shrink-0"></div>
                        <div>
                            <span class="font-medium text-green-700">价值迭代：</span>
                            直接更新状态价值函数，最后提取最优策略
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <script>
        /**
         * 悬崖漫步环境
         */
        class CliffWalkingEnv {
          constructor(ncol = 12, nrow = 4) {
            this.ncol = ncol; // 网格世界的列数
            this.nrow = nrow; // 网格世界的行数
            // 转移矩阵 P[state][action] = [{p, next_state, reward, done}]
            this.P = this.createP();
          }

          /**
           * 创建状态转移矩阵
           */
          createP() {
            // 初始化转移矩阵
            const P = Array(this.nrow * this.ncol).fill().map(() => 
              Array(4).fill().map(() => [])
            );

            // 四种动作: 0-上, 1-下, 2-左, 3-右
            const change = [[0, -1], [0, 1], [-1, 0], [1, 0]];
            
            for (let i = 0; i < this.nrow; i++) {
              for (let j = 0; j < this.ncol; j++) {
                for (let a = 0; a < 4; a++) {
                  const state = i * this.ncol + j;
                  // 判断是否是悬崖或终点
                  if (state === this.nrow * this.ncol - 1) {
                    // 终点
                    P[state][a].push({
                      p: 1.0,
                      next_state: state,
                      reward: 0,
                      done: true
                    });
                    continue;
                  }
                  
                  if (i === this.nrow - 1 && j > 0 && j < this.ncol - 1) {
                    // 悬崖
                    P[state][a].push({
                      p: 1.0,
                      next_state: (this.nrow - 1) * this.ncol,
                      reward: -100,
                      done: true
                    });
                    continue;
                  }
                  
                  // 计算下一个状态
                  let next_i = i + change[a][1];
                  let next_j = j + change[a][0];
                  let reward = -1.0;
                  let done = false;
                  
                  // 边界处理
                  if (next_i < 0 || next_i >= this.nrow || 
                      next_j < 0 || next_j >= this.ncol) {
                    next_i = i;
                    next_j = j;
                  }
                  
                  let next_state = next_i * this.ncol + next_j;
                  
                  // 如果下一个状态是悬崖
                  if (next_i === this.nrow - 1 && next_j > 0 && next_j < this.ncol - 1) {
                    next_state = (this.nrow - 1) * this.ncol;
                    reward = -100;
                    done = true;
                  }
                  
                  // 如果下一个状态是终点
                  if (next_state === this.nrow * this.ncol - 1) {
                    done = true;
                  }
                  
                  P[state][a].push({
                    p: 1.0,
                    next_state: next_state,
                    reward: reward,
                    done: done
                  });
                }
              }
            }
            
            return P;
          }
        }

        /**
         * 策略迭代算法
         */
        class PolicyIteration {
          constructor(env, theta = 1e-5, gamma = 0.9) {
            this.env = env;
            this.theta = theta; // 收敛阈值
            this.gamma = gamma; // 折扣因子
            this.v = Array(env.nrow * env.ncol).fill(0); // 状态价值
            this.pi = Array(env.nrow * env.ncol).fill().map(() => 
              Array(4).fill(0.25)
            ); // 初始策略为均匀随机
            this.policyStable = false; // 策略是否稳定
            this.iterationCount = 0; // 迭代次数
            this.evaluationIterations = []; // 每次策略评估的迭代次数
          }

          /**
           * 策略评估
           */
          policyEvaluation() {
            let iteration = 0;
            while (true) {
              let delta = 0;
              for (let s = 0; s < this.env.nrow * this.env.ncol; s++) {
                let v = this.v[s];
                let new_v = 0;
                
                for (let a = 0; a < 4; a++) {
                  for (const {p, next_state, reward} of this.env.P[s][a]) {
                    new_v += this.pi[s][a] * p * (reward + this.gamma * this.v[next_state]);
                  }
                }
                
                this.v[s] = new_v;
                delta = Math.max(delta, Math.abs(v - new_v));
              }
              
              iteration++;
              
              if (delta < this.theta) {
                return iteration;
              }
              
              // 防止无限循环
              if (iteration > 1000) {
                return iteration;
              }
            }
          }

          /**
           * 策略提升
           */
          policyImprovement() {
            let policy_stable = true;
            
            for (let s = 0; s < this.env.nrow * this.env.ncol; s++) {
              const old_action_probs = [...this.pi[s]];
              
              // 计算Q(s,a)
              const q_sa = Array(4).fill(0);
              
              for (let a = 0; a < 4; a++) {
                for (const {p, next_state, reward} of this.env.P[s][a]) {
                  q_sa[a] += p * (reward + this.gamma * this.v[next_state]);
                }
              }
              
              // 找到最优动作
              const best_a = q_sa.indexOf(Math.max(...q_sa));
              
              // 更新策略为确定性策略
              this.pi[s] = Array(4).fill(0);
              this.pi[s][best_a] = 1.0;
              
              // 检查策略是否稳定
              if (JSON.stringify(old_action_probs) !== JSON.stringify(this.pi[s])) {
                policy_stable = false;
              }
            }
            
            return policy_stable;
          }

          /**
           * 策略迭代
           */
          policyIteration() {
            this.policyStable = false;
            this.iterationCount = 0;
            this.evaluationIterations = [];
            
            while (!this.policyStable) {
              const evalIterations = this.policyEvaluation();
              this.evaluationIterations.push(evalIterations);
              
              this.policyStable = this.policyImprovement();
              this.iterationCount++;
              
              // 防止无限循环
              if (this.iterationCount > 20) {
                break;
              }
            }
            
            return {
              policyIterations: this.iterationCount,
              policyEvaluation: this.evaluationIterations
            };
          }
          
          /**
           * 执行单步策略迭代
           */
          singleStepIteration() {
            if (this.policyStable) {
              return {
                policyIterations: this.iterationCount,
                policyEvaluation: this.evaluationIterations,
                isComplete: true
              };
            }
            
            const evalIterations = this.policyEvaluation();
            this.evaluationIterations.push(evalIterations);
            
            this.policyStable = this.policyImprovement();
            this.iterationCount++;
            
            // 防止无限循环
            if (this.iterationCount > 20) {
              this.policyStable = true;
            }
            
            return {
              policyIterations: this.iterationCount,
              policyEvaluation: this.evaluationIterations,
              isComplete: this.policyStable
            };
          }
        }

        /**
         * 价值迭代算法
         */
        class ValueIteration {
          constructor(env, theta = 1e-5, gamma = 0.9) {
            this.env = env;
            this.theta = theta; // 收敛阈值
            this.gamma = gamma; // 折扣因子
            this.v = Array(env.nrow * env.ncol).fill(0); // 状态价值
            this.pi = Array(env.nrow * env.ncol).fill().map(() => 
              Array(4).fill(0.25)
            ); // 策略
            this.iterationCount = 0; // 迭代次数
            this.isComplete = false; // 是否完成
            this.maxDelta = Infinity; // 最大误差
          }

          /**
           * 价值迭代
           */
          valueIteration() {
            this.iterationCount = 0;
            this.isComplete = false;
            this.maxDelta = Infinity;
            
            while (!this.isComplete) {
              const result = this.singleStepIteration();
              if (result.isComplete) {
                break;
              }
            }
            
            return this.iterationCount;
          }
          
          /**
           * 执行单步价值迭代
           */
          singleStepIteration() {
            if (this.isComplete) {
              return {
                iterationCount: this.iterationCount,
                isComplete: true
              };
            }
            
            let delta = 0;
            this.iterationCount++;
            
            for (let s = 0; s < this.env.nrow * this.env.ncol; s++) {
              const v = this.v[s];
              
              // 计算每个动作的价值
              const q_sa = Array(4).fill(0);
              
              for (let a = 0; a < 4; a++) {
                for (const {p, next_state, reward} of this.env.P[s][a]) {
                  q_sa[a] += p * (reward + this.gamma * this.v[next_state]);
                }
              }
              
              // 更新状态价值为最大的动作价值
              this.v[s] = Math.max(...q_sa);
              
              // 计算最大误差
              delta = Math.max(delta, Math.abs(v - this.v[s]));
            }
            
            this.maxDelta = delta;
            
            // 在每次迭代后更新策略，而不是等到收敛
            this.extractPolicy();
            
            // 检查是否收敛
            if (delta < this.theta || this.iterationCount > 1000) {
              this.isComplete = true;
            }
            
            return {
              iterationCount: this.iterationCount,
              maxDelta: this.maxDelta,
              isComplete: this.isComplete
            };
          }
          
          /**
           * 从价值函数提取策略
           */
          extractPolicy() {
            for (let s = 0; s < this.env.nrow * this.env.ncol; s++) {
              const q_sa = Array(4).fill(0);
              
              for (let a = 0; a < 4; a++) {
                for (const {p, next_state, reward} of this.env.P[s][a]) {
                  q_sa[a] += p * (reward + this.gamma * this.v[next_state]);
                }
              }
              
              // 找到最优动作
              const best_a = q_sa.indexOf(Math.max(...q_sa));
              
              // 更新策略为确定性策略
              this.pi[s] = Array(4).fill(0);
              this.pi[s][best_a] = 1.0;
            }
          }
        }

        // 初始化环境
        const env = new CliffWalkingEnv();
        const actionMeaning = ['↑', '↓', '←', '→'];
        
        // 悬崖位置和目标位置
        const cliffPos = Array.from({length: 10}, (_, i) => (env.nrow - 1) * env.ncol + i + 1);
        const goalPos = [env.nrow * env.ncol - 1];
        const startPos = (env.nrow - 1) * env.ncol;
        
        // 生成随机策略
        function generateRandomPolicy() {
          // 创建大小为4的数组，表示四个动作的概率
          const policy = Array(4).fill(0);
          
          // 随机选择一个动作赋予100%概率
          const randomAction = Math.floor(Math.random() * 4);
          policy[randomAction] = 1.0;
          
          return policy;
        }
        
        // 创建初始随机策略
        let randomPolicies = Array(env.nrow * env.ncol).fill().map(() => 
          generateRandomPolicy()
        );
        
        // 创建所有网格
        function createAllGrids() {
          createGrid('policyIterationValueGrid');
          createGrid('policyIterationPolicyGrid');
          createGrid('valueIterationValueGrid');
          createGrid('valueIterationPolicyGrid');
        }
        
        // 创建网格
        function createGrid(gridId) {
          const gridContainer = document.getElementById(gridId);
          gridContainer.innerHTML = '';
          
          for (let i = 0; i < env.nrow; i++) {
            for (let j = 0; j < env.ncol; j++) {
              const cell = document.createElement('div');
              cell.className = 'cell';
              
              const state = i * env.ncol + j;
              
              // 设置单元格类型
              if (state === startPos) {
                cell.classList.add('start');
                cell.innerHTML = 'S';
              } else if (state === goalPos[0]) {
                cell.classList.add('goal');
                cell.innerHTML = 'G';
              } else if (cliffPos.includes(state)) {
                cell.classList.add('cliff');
                cell.innerHTML = 'C';
              }
              
              gridContainer.appendChild(cell);
            }
          }
        }
        
        // 显示初始环境状态
        function showInitialState() {
          // 显示所有状态值为0
          showInitialValues('policyIterationValueGrid');
          showInitialValues('valueIterationValueGrid');
          
          // 显示随机策略
          showInitialPolicies('policyIterationPolicyGrid');
          showInitialPolicies('valueIterationPolicyGrid');
          
          // 清空结果区域
          document.getElementById('policyIterationResults').innerHTML = '';
          document.getElementById('valueIterationResults').innerHTML = '';
        }
        
        // 显示初始状态值
        function showInitialValues(gridId) {
          const cells = document.querySelectorAll(`#${gridId} .cell`);
          
          for (let i = 0; i < env.nrow; i++) {
            for (let j = 0; j < env.ncol; j++) {
              const state = i * env.ncol + j;
              const cell = cells[state];
              
              // 显示状态价值
              if (state === startPos) {
                cell.classList.add('start');
                cell.innerHTML = `S<br><span class="value-text">0.00</span>`;
              } else if (state === goalPos[0]) {
                cell.classList.add('goal');
                cell.innerHTML = `G<br><span class="value-text">0.00</span>`;
              } else if (cliffPos.includes(state)) {
                cell.classList.add('cliff');
                cell.innerHTML = `C<br><span class="value-text">0.00</span>`;
              } else {
                cell.innerHTML = `<span class="value-text">0.00</span>`;
              }
            }
          }
        }
        
        // 显示初始随机策略
        function showInitialPolicies(gridId) {
          const cells = document.querySelectorAll(`#${gridId} .cell`);
          
          for (let i = 0; i < env.nrow; i++) {
            for (let j = 0; j < env.ncol; j++) {
              const state = i * env.ncol + j;
              const cell = cells[state];
              
              if (state === startPos) {
                cell.innerHTML = 'S';
              } else if (state === goalPos[0]) {
                cell.innerHTML = 'G';
              } else if (cliffPos.includes(state)) {
                cell.innerHTML = 'C';
              } else {
                // 显示随机策略方向
                const best_a = randomPolicies[state].indexOf(1.0);
                cell.innerHTML = actionMeaning[best_a];
              }
            }
          }
        }
        
        // 更新状态价值网格
        function updateValueGrid(agent, gridId) {
          const cells = document.querySelectorAll(`#${gridId} .cell`);
          
          for (let i = 0; i < env.nrow; i++) {
            for (let j = 0; j < env.ncol; j++) {
              const state = i * env.ncol + j;
              const cell = cells[state];
              
              // 显示状态价值
              const stateValue = agent.v[state].toFixed(2);
              
              // 设置单元格类型和内容
              if (state === startPos) {
                cell.classList.add('start');
                cell.innerHTML = `S<br><span class="value-text">${stateValue}</span>`;
              } else if (state === goalPos[0]) {
                cell.classList.add('goal');
                cell.innerHTML = `G<br><span class="value-text">${stateValue}</span>`;
              } else if (cliffPos.includes(state)) {
                cell.classList.add('cliff');
                cell.innerHTML = `C<br><span class="value-text">${stateValue}</span>`;
              } else {
                cell.innerHTML = `<span class="value-text">${stateValue}</span>`;
              }
            }
          }
        }
        
        // 更新策略网格
        function updatePolicyGrid(agent, gridId) {
          const cells = document.querySelectorAll(`#${gridId} .cell`);
          
          for (let i = 0; i < env.nrow; i++) {
            for (let j = 0; j < env.ncol; j++) {
              const state = i * env.ncol + j;
              const cell = cells[state];
              
              // 设置单元格类型和内容
              if (state === startPos) {
                cell.classList.add('start');
                cell.innerHTML = 'S';
              } else if (state === goalPos[0]) {
                cell.classList.add('goal');
                cell.innerHTML = 'G';
              } else if (cliffPos.includes(state)) {
                cell.classList.add('cliff');
                cell.innerHTML = 'C';
              } else {
                // 找到最优动作
                const best_a = agent.pi[state].indexOf(Math.max(...agent.pi[state]));
                cell.innerHTML = actionMeaning[best_a];
              }
            }
          }
        }
        
        // 重置策略迭代环境
        function resetPolicyIteration() {
          // 重新生成随机策略
          randomPolicies = Array(env.nrow * env.ncol).fill().map(() => 
            generateRandomPolicy()
          );
          
          // 重置算法实例
          policyAgent = null;
          
          // 显示初始状态
          showInitialValues('policyIterationValueGrid');
          showInitialPolicies('policyIterationPolicyGrid');
          
          // 清空结果区域
          document.getElementById('policyIterationResults').innerHTML = '';
        }
        
        // 重置价值迭代环境
        function resetValueIteration() {
          // 重新生成随机策略
          randomPolicies = Array(env.nrow * env.ncol).fill().map(() => 
            generateRandomPolicy()
          );
          
          // 重置算法实例
          valueAgent = null;
          
          // 显示初始状态
          showInitialValues('valueIterationValueGrid');
          showInitialPolicies('valueIterationPolicyGrid');
          
          // 清空结果区域
          document.getElementById('valueIterationResults').innerHTML = '';
        }

        // 显示结果
        function showResults(algorithmName, agent, iterations) {
          const resultsId = algorithmName === '策略迭代' ? 'policyIterationResults' : 'valueIterationResults';
          const resultsDiv = document.getElementById(resultsId);
          let html = '';
          
          if (algorithmName === '策略迭代') {
            const isComplete = iterations.isComplete;
            const badgeClass = isComplete ? 'converged-badge' : 'iteration-badge';
            html += `
              <div class="flex items-center gap-2 text-sm">
                <span>策略迭代次数:</span>
                <span class="${badgeClass}">${iterations.policyIterations}</span>
                <span>|</span>
                <span>策略评估:</span>
                <span class="text-blue-600 font-medium">[${iterations.policyEvaluation.join(', ')}]</span>
                ${isComplete ? '<span class="text-green-600 font-semibold flex items-center"><svg class="w-4 h-4 mr-1" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"></path></svg>策略已收敛!</span>' : ''}
              </div>
            `;
          } else {
            const isComplete = iterations.isComplete;
            const badgeClass = isComplete ? 'converged-badge' : 'iteration-badge';
            html += `
              <div class="flex items-center gap-2 text-sm">
                <span>价值迭代次数:</span>
                <span class="${badgeClass}">${iterations.iterationCount}</span>
                <span>|</span>
                <span>最大误差:</span>
                <span class="text-purple-600 font-medium">${iterations.maxDelta?.toFixed(5) || 'N/A'}</span>
                ${isComplete ? '<span class="text-green-600 font-semibold flex items-center"><svg class="w-4 h-4 mr-1" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"></path></svg>价值已收敛!</span>' : ''}
              </div>
            `;
          }
          
          resultsDiv.innerHTML = html;
        }

        // 全局算法实例
        let policyAgent = null;
        let valueAgent = null;
        
        // 绑定按钮事件
        document.getElementById('policyIterationBtn').addEventListener('click', function() {
          policyAgent = new PolicyIteration(env);
          const iterations = policyAgent.policyIteration();
          updateValueGrid(policyAgent, 'policyIterationValueGrid');
          updatePolicyGrid(policyAgent, 'policyIterationPolicyGrid');
          showResults('策略迭代', policyAgent, iterations);
        });
        
        document.getElementById('valueIterationBtn').addEventListener('click', function() {
          valueAgent = new ValueIteration(env);
          const iterations = valueAgent.valueIteration();
          updateValueGrid(valueAgent, 'valueIterationValueGrid');
          updatePolicyGrid(valueAgent, 'valueIterationPolicyGrid');
          showResults('价值迭代', valueAgent, {
            iterationCount: iterations,
            maxDelta: valueAgent.maxDelta,
            isComplete: valueAgent.isComplete
          });
        });
        
        document.getElementById('singleStepPolicyBtn').addEventListener('click', function() {
          // 如果没有实例，创建一个新的
          if (!policyAgent) {
            policyAgent = new PolicyIteration(env);
          }
          
          // 运行一步迭代
          const iterations = policyAgent.singleStepIteration();
          
          // 更新视图
          updateValueGrid(policyAgent, 'policyIterationValueGrid');
          updatePolicyGrid(policyAgent, 'policyIterationPolicyGrid');
          showResults('策略迭代', policyAgent, iterations);
        });
        
        document.getElementById('singleStepValueBtn').addEventListener('click', function() {
          // 如果没有实例，创建一个新的
          if (!valueAgent) {
            valueAgent = new ValueIteration(env);
          }
          
          // 运行一步迭代
          const iterations = valueAgent.singleStepIteration();
          
          // 更新视图
          updateValueGrid(valueAgent, 'valueIterationValueGrid');
          updatePolicyGrid(valueAgent, 'valueIterationPolicyGrid');
          showResults('价值迭代', valueAgent, iterations);
        });
        
        document.getElementById('resetPolicyIterationBtn').addEventListener('click', function() {
          resetPolicyIteration();
        });
        
        document.getElementById('resetValueIterationBtn').addEventListener('click', function() {
          resetValueIteration();
        });
        
        // 初始化所有网格
        createAllGrids();
        
        // 初始显示环境状态
        showInitialState();
    </script>
</body>
</html> 