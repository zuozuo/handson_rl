<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>时序差分算法可视化</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        border: "hsl(214.3 31.8% 91.4%)",
                        input: "hsl(214.3 31.8% 91.4%)",
                        ring: "hsl(222.2 84% 4.9%)",
                        background: "hsl(0 0% 100%)",
                        foreground: "hsl(222.2 84% 4.9%)",
                        primary: {
                            DEFAULT: "hsl(222.2 47.4% 11.2%)",
                            foreground: "hsl(210 40% 98%)",
                        },
                        secondary: {
                            DEFAULT: "hsl(210 40% 96%)",
                            foreground: "hsl(222.2 84% 4.9%)",
                        },
                        destructive: {
                            DEFAULT: "hsl(0 84.2% 60.2%)",
                            foreground: "hsl(210 40% 98%)",
                        },
                        muted: {
                            DEFAULT: "hsl(210 40% 96%)",
                            foreground: "hsl(215.4 16.3% 46.9%)",
                        },
                        accent: {
                            DEFAULT: "hsl(210 40% 96%)",
                            foreground: "hsl(222.2 84% 4.9%)",
                        },
                        card: {
                            DEFAULT: "hsl(0 0% 100%)",
                            foreground: "hsl(222.2 84% 4.9%)",
                        },
                    },
                    borderRadius: {
                        lg: "var(--radius)",
                        md: "calc(var(--radius) - 2px)",
                        sm: "calc(var(--radius) - 4px)",
                    },
                }
            }
        }
    </script>
    <style>
        :root {
            --radius: 0.5rem;
        }
        .grid-container {
            display: grid;
            grid-template-columns: repeat(12, 35px);
            grid-template-rows: repeat(4, 35px);
            gap: 1px;
            border-radius: 6px;
            overflow: hidden;
            border: 1px solid hsl(214.3 31.8% 91.4%);
        }
        .cell {
            width: 35px;
            height: 35px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 10px;
            background-color: white;
            border-right: 1px solid hsl(214.3 31.8% 91.4%);
            border-bottom: 1px solid hsl(214.3 31.8% 91.4%);
        }
        .cell:nth-child(12n) {
            border-right: none;
        }
        .cell:nth-last-child(-n+12) {
            border-bottom: none;
        }
        .start {
            background-color: hsl(142.1 76.2% 36.3%);
            color: white;
        }
        .goal {
            background-color: hsl(47.9 95.8% 53.1%);
            color: hsl(222.2 84% 4.9%);
        }
        .cliff {
            background-color: hsl(0 84.2% 60.2%);
            color: white;
        }
        .value-text {
            font-weight: 400;
            font-size: 8px;
            color: hsl(215.4 16.3% 46.9%);
            margin-top: 2px;
        }
    </style>
</head>
<body class="min-h-screen bg-slate-50">
    <div class="container mx-auto px-6 py-8 max-w-7xl">
        <!-- Header -->
        <div class="text-center mb-8">
            <h1 class="text-4xl font-bold tracking-tight text-gray-900 mb-4">
                时序差分算法可视化与学习曲线分析
            </h1>
            <p class="text-lg text-muted-foreground">
                通过交互式可视化深入理解 Sarsa 和 Q-learning 算法的学习过程
            </p>
        </div>
        
        <!-- Legend -->
        <div class="flex justify-center items-center gap-6 mb-8 p-4 bg-card rounded-lg border shadow-sm">
            <div class="flex items-center gap-2">
                <div class="w-4 h-4 rounded bg-green-600"></div>
                <span class="text-sm font-medium">起点</span>
            </div>
            <div class="flex items-center gap-2">
                <div class="w-4 h-4 rounded bg-yellow-400"></div>
                <span class="text-sm font-medium">终点</span>
            </div>
            <div class="flex items-center gap-2">
                <div class="w-4 h-4 rounded bg-red-500"></div>
                <span class="text-sm font-medium">悬崖</span>
            </div>
        </div>

        <!-- Global Controls -->
        <div class="bg-card rounded-lg border shadow-sm p-6 mb-8">
            <h3 class="text-lg font-semibold mb-4">全局控制</h3>
            <div class="flex flex-wrap items-center gap-3 mb-4">
                <button id="trainBothBtn" class="inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 bg-primary text-primary-foreground hover:bg-primary/90 h-10 px-4 py-2">
                    同时训练两个算法
                </button>
                <button id="stepBothBtn" class="inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 border border-input bg-background hover:bg-accent hover:text-accent-foreground h-10 px-4 py-2">
                    同时单步训练
                </button>
                <button id="resetBothBtn" class="inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 bg-destructive text-destructive-foreground hover:bg-destructive/90 h-10 px-4 py-2">
                    重置所有算法
                </button>
                <button id="clearChartsBtn" class="inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 border border-input bg-background hover:bg-accent hover:text-accent-foreground h-10 px-4 py-2">
                    清空图表
                </button>
            </div>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div class="space-y-2">
                    <label class="text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70">训练回合数</label>
                    <input type="number" id="episodesInput" value="100" min="1" max="1000" class="flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50">
                </div>
                <div class="space-y-2">
                    <label class="text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70">移动平均窗口</label>
                    <input type="number" id="smoothingWindow" value="20" min="5" max="100" class="flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50">
                </div>
            </div>
        </div>

        <!-- Charts Section -->
        <div class="bg-card rounded-lg border shadow-sm p-6 mb-8">
            <h2 class="text-xl font-semibold mb-6">学习曲线分析</h2>
            <div class="bg-background rounded-lg border p-4">
                <h3 class="text-lg font-medium text-center mb-4">Sarsa vs Q-learning 综合学习曲线对比</h3>
                <div class="relative h-96">
                    <canvas id="combinedChart" class="w-full h-full"></canvas>
                </div>
            </div>
        </div>
        
        <!-- Algorithms Comparison -->
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
            <!-- Sarsa Algorithm -->
            <div class="bg-card rounded-lg border shadow-sm">
                <div class="p-6 border-b">
                    <h2 class="text-xl font-semibold text-blue-700">Sarsa算法 (在线策略)</h2>
                    <div id="sarsaResults" class="mt-2 text-sm text-muted-foreground"></div>
                </div>
                <div class="p-6 space-y-6">
                    <div class="text-center">
                        <h3 class="text-lg font-medium mb-4">策略</h3>
                        <div class="flex justify-center">
                            <div class="grid-container" id="sarsaPolicyGrid"></div>
                        </div>
                    </div>
                    <div class="text-center">
                        <h3 class="text-lg font-medium mb-4">状态价值</h3>
                        <div class="flex justify-center">
                            <div class="grid-container" id="sarsaValueGrid"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Q-learning Algorithm -->
            <div class="bg-card rounded-lg border shadow-sm">
                <div class="p-6 border-b">
                    <h2 class="text-xl font-semibold text-green-700">Q-learning算法 (离线策略)</h2>
                    <div id="qlearningResults" class="mt-2 text-sm text-muted-foreground"></div>
                </div>
                <div class="p-6 space-y-6">
                    <div class="text-center">
                        <h3 class="text-lg font-medium mb-4">策略</h3>
                        <div class="flex justify-center">
                            <div class="grid-container" id="qlearningPolicyGrid"></div>
                        </div>
                    </div>
                    <div class="text-center">
                        <h3 class="text-lg font-medium mb-4">状态价值</h3>
                        <div class="flex justify-center">
                            <div class="grid-container" id="qlearningValueGrid"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        /**
         * 悬崖漫步环境
         */
        class CliffWalkingEnv {
            constructor(ncol = 12, nrow = 4) {
                this.ncol = ncol;
                this.nrow = nrow;
                this.P = this.createP();
                this.reset();
            }

            createP() {
                const P = {};
                for (let s = 0; s < this.nrow * this.ncol; s++) {
                    P[s] = {};
                    for (let a = 0; a < 4; a++) {
                        P[s][a] = [];
                    }
                }

                const change = [[0, -1], [0, 1], [-1, 0], [1, 0]];

                for (let i = 0; i < this.nrow; i++) {
                    for (let j = 0; j < this.ncol; j++) {
                        for (let a = 0; a < 4; a++) {
                            const state = i * this.ncol + j;
                            
                            if (state === this.nrow * this.ncol - 1) {
                                P[state][a].push({p: 1.0, next_state: state, reward: 0, done: true});
                                continue;
                            }
                            
                            if (i === this.nrow - 1 && j > 0 && j < this.ncol - 1) {
                                P[state][a].push({p: 1.0, next_state: (this.nrow - 1) * this.ncol, reward: -100, done: true});
                                continue;
                            }
                            
                            let next_i = i + change[a][1];
                            let next_j = j + change[a][0];
                            let reward = -1.0;
                            let done = false;
                            
                            if (next_i < 0 || next_i >= this.nrow || next_j < 0 || next_j >= this.ncol) {
                                next_i = i;
                                next_j = j;
                            }
                            
                            let next_state = next_i * this.ncol + next_j;
                            
                            if (next_i === this.nrow - 1 && next_j > 0 && next_j < this.ncol - 1) {
                                next_state = (this.nrow - 1) * this.ncol;
                                reward = -100;
                                done = true;
                            }
                            
                            if (next_state === this.nrow * this.ncol - 1) {
                                done = true;
                            }
                            
                            P[state][a].push({p: 1.0, next_state: next_state, reward: reward, done: done});
                        }
                    }
                }
                
                return P;
            }

            reset() {
                this.state = (this.nrow - 1) * this.ncol;
                return this.state;
            }

            step(action) {
                const {p, next_state, reward, done} = this.P[this.state][action][0];
                this.state = next_state;
                return {next_state, reward, done};
            }
        }

        /**
         * Sarsa算法
         */
        class Sarsa {
            constructor(ncol, nrow, epsilon = 0.1, alpha = 0.1, gamma = 0.9) {
                this.Q_table = Array(nrow * ncol).fill().map(() => Array(4).fill(0));
                this.n_actions = 4;
                this.alpha = alpha;
                this.gamma = gamma;
                this.epsilon = epsilon;
                this.episode_count = 0;
                this.total_reward = 0;
                this.episode_rewards = [];
            }

            takeAction(state) {
                if (Math.random() < this.epsilon) {
                    return Math.floor(Math.random() * this.n_actions);
                } else {
                    return this.bestAction(state);
                }
            }

            bestAction(state) {
                return this.Q_table[state].indexOf(Math.max(...this.Q_table[state]));
            }

            update(s0, a0, r, s1, a1) {
                const td_error = r + this.gamma * this.Q_table[s1][a1] - this.Q_table[s0][a0];
                this.Q_table[s0][a0] += this.alpha * td_error;
            }

            trainEpisode(env) {
                let episode_return = 0;
                env.reset();
                let state = env.state;
                let action = this.takeAction(state);
                let done = false;

                while (!done) {
                    const {next_state, reward, done: is_done} = env.step(action);
                    const next_action = this.takeAction(next_state);
                    this.update(state, action, reward, next_state, next_action);
                    state = next_state;
                    action = next_action;
                    episode_return += reward;
                    done = is_done;
                }

                this.episode_count++;
                this.total_reward += episode_return;
                this.episode_rewards.push(episode_return);
                return episode_return;
            }

            getStateValues() {
                return this.Q_table.map(q_values => Math.max(...q_values));
            }
        }

        /**
         * Q-learning算法
         */
        class QLearning {
            constructor(ncol, nrow, epsilon = 0.1, alpha = 0.1, gamma = 0.9) {
                this.Q_table = Array(nrow * ncol).fill().map(() => Array(4).fill(0));
                this.n_actions = 4;
                this.alpha = alpha;
                this.gamma = gamma;
                this.epsilon = epsilon;
                this.episode_count = 0;
                this.total_reward = 0;
                this.episode_rewards = [];
            }

            takeAction(state) {
                if (Math.random() < this.epsilon) {
                    return Math.floor(Math.random() * this.n_actions);
                } else {
                    return this.bestAction(state);
                }
            }

            bestAction(state) {
                return this.Q_table[state].indexOf(Math.max(...this.Q_table[state]));
            }

            update(s0, a0, r, s1) {
                const td_error = r + this.gamma * Math.max(...this.Q_table[s1]) - this.Q_table[s0][a0];
                this.Q_table[s0][a0] += this.alpha * td_error;
            }

            trainEpisode(env) {
                let episode_return = 0;
                env.reset();
                let state = env.state;
                let done = false;

                while (!done) {
                    const action = this.takeAction(state);
                    const {next_state, reward, done: is_done} = env.step(action);
                    this.update(state, action, reward, next_state);
                    state = next_state;
                    episode_return += reward;
                    done = is_done;
                }

                this.episode_count++;
                this.total_reward += episode_return;
                this.episode_rewards.push(episode_return);
                return episode_return;
            }

            getStateValues() {
                return this.Q_table.map(q_values => Math.max(...q_values));
            }
        }

        // 初始化环境和算法
        const env = new CliffWalkingEnv();
        const actionMeaning = ['↑', '↓', '←', '→'];
        
        // 悬崖位置和目标位置
        const cliffPos = Array.from({length: 10}, (_, i) => (env.nrow - 1) * env.ncol + i + 1);
        const goalPos = [env.nrow * env.ncol - 1];
        const startPos = (env.nrow - 1) * env.ncol;

        // 算法实例
        let sarsaAgent = new Sarsa(env.ncol, env.nrow);
        let qlearningAgent = new QLearning(env.ncol, env.nrow);

        // 图表实例
        let combinedChart;

        // 移动平均计算函数
        function calculateMovingAverage(data, windowSize) {
            const result = [];
            for (let i = 0; i < data.length; i++) {
                const start = Math.max(0, i - windowSize + 1);
                const subset = data.slice(start, i + 1);
                const average = subset.reduce((sum, val) => sum + val, 0) / subset.length;
                result.push(average);
            }
            return result;
        }

        // 初始化图表
        function initializeCharts() {
            // 综合图表
            const combinedCtx = document.getElementById('combinedChart').getContext('2d');
            combinedChart = new Chart(combinedCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Sarsa Episode Reward',
                        data: [],
                        borderColor: 'rgb(59, 130, 246)',
                        backgroundColor: 'rgba(59, 130, 246, 0.1)',
                        borderWidth: 1.5,
                        pointRadius: 0,
                        fill: false
                    }, {
                        label: 'Sarsa Moving Average',
                        data: [],
                        borderColor: 'rgb(239, 68, 68)',
                        backgroundColor: 'rgba(239, 68, 68, 0.1)',
                        borderWidth: 3,
                        pointRadius: 0,
                        fill: false
                    }, {
                        label: 'Q-learning Episode Reward',
                        data: [],
                        borderColor: 'rgb(34, 197, 94)',
                        backgroundColor: 'rgba(34, 197, 94, 0.1)',
                        borderWidth: 1.5,
                        pointRadius: 0,
                        fill: false
                    }, {
                        label: 'Q-learning Moving Average',
                        data: [],
                        borderColor: 'rgb(251, 146, 60)',
                        backgroundColor: 'rgba(251, 146, 60, 0.1)',
                        borderWidth: 3,
                        pointRadius: 0,
                        fill: false
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: false,
                            title: {
                                display: true,
                                text: 'Return',
                                font: {
                                    size: 14,
                                    family: 'Inter, ui-sans-serif, system-ui'
                                },
                                color: 'hsl(215.4 16.3% 46.9%)'
                            },
                            grid: {
                                color: 'hsl(214.3 31.8% 91.4%)',
                                borderColor: 'hsl(214.3 31.8% 91.4%)'
                            },
                            ticks: {
                                color: 'hsl(215.4 16.3% 46.9%)',
                                font: {
                                    family: 'Inter, ui-sans-serif, system-ui'
                                }
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Episodes',
                                font: {
                                    size: 14,
                                    family: 'Inter, ui-sans-serif, system-ui'
                                },
                                color: 'hsl(215.4 16.3% 46.9%)'
                            },
                            grid: {
                                color: 'hsl(214.3 31.8% 91.4%)',
                                borderColor: 'hsl(214.3 31.8% 91.4%)'
                            },
                            ticks: {
                                color: 'hsl(215.4 16.3% 46.9%)',
                                font: {
                                    family: 'Inter, ui-sans-serif, system-ui'
                                }
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                usePointStyle: true,
                                padding: 20,
                                font: {
                                    size: 12,
                                    family: 'Inter, ui-sans-serif, system-ui'
                                },
                                color: 'hsl(222.2 84% 4.9%)'
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            backgroundColor: 'hsl(222.2 47.4% 11.2%)',
                            titleColor: 'hsl(210 40% 98%)',
                            bodyColor: 'hsl(210 40% 98%)',
                            borderColor: 'hsl(214.3 31.8% 91.4%)',
                            borderWidth: 1,
                            titleFont: {
                                family: 'Inter, ui-sans-serif, system-ui'
                            },
                            bodyFont: {
                                family: 'Inter, ui-sans-serif, system-ui'
                            }
                        }
                    },
                    interaction: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: false
                    },
                    animation: {
                        duration: 200
                    }
                }
            });
        }

        // 更新图表
        function updateCharts() {
            const windowSize = parseInt(document.getElementById('smoothingWindow').value);
            
            // 确定最大回合数
            const maxEpisodes = Math.max(
                sarsaAgent.episode_rewards.length, 
                qlearningAgent.episode_rewards.length
            );
            
            if (maxEpisodes > 0) {
                const labels = Array.from({length: maxEpisodes}, (_, i) => i + 1);
                
                // 计算移动平均
                const sarsaMovingAvg = sarsaAgent.episode_rewards.length > 0 
                    ? calculateMovingAverage(sarsaAgent.episode_rewards, windowSize) 
                    : [];
                const qlearningMovingAvg = qlearningAgent.episode_rewards.length > 0 
                    ? calculateMovingAverage(qlearningAgent.episode_rewards, windowSize) 
                    : [];

                // 更新综合图表
                combinedChart.data.labels = labels;
                
                // Sarsa数据
                combinedChart.data.datasets[0].data = sarsaAgent.episode_rewards.length > 0 
                    ? sarsaAgent.episode_rewards 
                    : [];
                combinedChart.data.datasets[1].data = sarsaMovingAvg;
                
                // Q-learning数据
                combinedChart.data.datasets[2].data = qlearningAgent.episode_rewards.length > 0 
                    ? qlearningAgent.episode_rewards 
                    : [];
                combinedChart.data.datasets[3].data = qlearningMovingAvg;
                
                combinedChart.update('none');
            }
        }

        // 清空图表
        function clearCharts() {
            combinedChart.data.labels = [];
            combinedChart.data.datasets[0].data = [];
            combinedChart.data.datasets[1].data = [];
            combinedChart.data.datasets[2].data = [];
            combinedChart.data.datasets[3].data = [];
            combinedChart.update();
        }

        // 创建网格
        function createGrid(gridId) {
            const gridContainer = document.getElementById(gridId);
            gridContainer.innerHTML = '';
            
            for (let i = 0; i < env.nrow; i++) {
                for (let j = 0; j < env.ncol; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    
                    const state = i * env.ncol + j;
                    
                    if (state === startPos) {
                        cell.classList.add('start');
                        cell.innerHTML = 'S';
                    } else if (state === goalPos[0]) {
                        cell.classList.add('goal');
                        cell.innerHTML = 'G';
                    } else if (cliffPos.includes(state)) {
                        cell.classList.add('cliff');
                        cell.innerHTML = 'C';
                    }
                    
                    gridContainer.appendChild(cell);
                }
            }
        }

        // 更新策略网格
        function updatePolicyGrid(agent, gridId) {
            const cells = document.querySelectorAll(`#${gridId} .cell`);
            
            for (let i = 0; i < env.nrow; i++) {
                for (let j = 0; j < env.ncol; j++) {
                    const state = i * env.ncol + j;
                    const cell = cells[state];
                    
                    if (state === startPos) {
                        cell.innerHTML = 'S';
                    } else if (state === goalPos[0]) {
                        cell.innerHTML = 'G';
                    } else if (cliffPos.includes(state)) {
                        cell.innerHTML = 'C';
                    } else {
                        const best_a = agent.bestAction(state);
                        const arrow = actionMeaning[best_a];
                        cell.innerHTML = arrow;
                    }
                }
            }
        }

        // 更新状态价值网格
        function updateValueGrid(agent, gridId) {
            const cells = document.querySelectorAll(`#${gridId} .cell`);
            const stateValues = agent.getStateValues();
            
            for (let i = 0; i < env.nrow; i++) {
                for (let j = 0; j < env.ncol; j++) {
                    const state = i * env.ncol + j;
                    const cell = cells[state];
                    const stateValue = stateValues[state].toFixed(2);
                    
                    if (state === startPos) {
                        cell.innerHTML = `S<br><span class="value-text">${stateValue}</span>`;
                    } else if (state === goalPos[0]) {
                        cell.innerHTML = `G<br><span class="value-text">${stateValue}</span>`;
                    } else if (cliffPos.includes(state)) {
                        cell.innerHTML = `C<br><span class="value-text">${stateValue}</span>`;
                    } else {
                        cell.innerHTML = `<span class="value-text">${stateValue}</span>`;
                    }
                }
            }
        }

        // 显示结果
        function showResults(algorithmName, agent) {
            const resultsId = algorithmName === 'Sarsa' ? 'sarsaResults' : 'qlearningResults';
            const resultsDiv = document.getElementById(resultsId);
            
            const avgReward = agent.episode_count > 0 ? (agent.total_reward / agent.episode_count).toFixed(2) : '0.00';
            const lastReward = agent.episode_rewards.length > 0 ? agent.episode_rewards[agent.episode_rewards.length - 1] : 0;
            
            resultsDiv.innerHTML = `
                <p>训练回合: ${agent.episode_count} | 最后回合奖励: ${lastReward} | 平均奖励: ${avgReward}</p>
            `;
        }

        // 初始化所有网格
        function initializeGrids() {
            createGrid('sarsaPolicyGrid');
            createGrid('sarsaValueGrid');
            createGrid('qlearningPolicyGrid');
            createGrid('qlearningValueGrid');
            
            // 显示初始状态
            updatePolicyGrid(sarsaAgent, 'sarsaPolicyGrid');
            updateValueGrid(sarsaAgent, 'sarsaValueGrid');
            updatePolicyGrid(qlearningAgent, 'qlearningPolicyGrid');
            updateValueGrid(qlearningAgent, 'qlearningValueGrid');
            
            showResults('Sarsa', sarsaAgent);
            showResults('Q-learning', qlearningAgent);
        }

        // 训练函数
        function trainAgent(agent, algorithmName, episodes = 1) {
            for (let i = 0; i < episodes; i++) {
                const env_copy = new CliffWalkingEnv();
                agent.trainEpisode(env_copy);
            }
            
            const policyGridId = algorithmName === 'Sarsa' ? 'sarsaPolicyGrid' : 'qlearningPolicyGrid';
            const valueGridId = algorithmName === 'Sarsa' ? 'sarsaValueGrid' : 'qlearningValueGrid';
            updatePolicyGrid(agent, policyGridId);
            updateValueGrid(agent, valueGridId);
            showResults(algorithmName, agent);
            
            // 更新图表和统计信息
            updateCharts();
        }

        // 重置算法
        function resetAgent(agent, algorithmName) {
            agent.Q_table = Array(env.nrow * env.ncol).fill().map(() => Array(4).fill(0));
            agent.episode_count = 0;
            agent.total_reward = 0;
            agent.episode_rewards = [];
            
            const policyGridId = algorithmName === 'Sarsa' ? 'sarsaPolicyGrid' : 'qlearningPolicyGrid';
            const valueGridId = algorithmName === 'Sarsa' ? 'sarsaValueGrid' : 'qlearningValueGrid';
            updatePolicyGrid(agent, policyGridId);
            updateValueGrid(agent, valueGridId);
            showResults(algorithmName, agent);
            
            // 更新图表和统计信息
            updateCharts();
        }

        // 绑定事件监听器
        document.getElementById('trainBothBtn').addEventListener('click', function() {
            const episodes = parseInt(document.getElementById('episodesInput').value);
            trainAgent(sarsaAgent, 'Sarsa', episodes);
            trainAgent(qlearningAgent, 'Q-learning', episodes);
        });

        document.getElementById('stepBothBtn').addEventListener('click', function() {
            trainAgent(sarsaAgent, 'Sarsa', 1);
            trainAgent(qlearningAgent, 'Q-learning', 1);
        });

        document.getElementById('resetBothBtn').addEventListener('click', function() {
            sarsaAgent = new Sarsa(env.ncol, env.nrow);
            qlearningAgent = new QLearning(env.ncol, env.nrow);
            initializeGrids();
            updateCharts();
        });

        document.getElementById('clearChartsBtn').addEventListener('click', function() {
            clearCharts();
        });

        // 移动平均窗口变化时更新图表
        document.getElementById('smoothingWindow').addEventListener('change', function() {
            updateCharts();
        });

        // 页面加载完成后初始化
        window.addEventListener('load', function() {
            initializeCharts();
            initializeGrids();
        });
    </script>
</body>
</html> 